using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Coppel.funciones;

namespace ClienteConsola
{
    class Program
    {
        static void Main(string[] args)
        {
            //IntroNET();
            //UsoLPComentarios();
            //UsoLPVariables();
            //UsoLPSinonimos();
            //UsoLPInferenciaTipos();
            //UsoLPAusenciaValor();
            //UsoLPAlcances();
            //UsoLPEnumeraciones();

            //UsoLPOperadores();
            //UsoLPOperadoresCategorias();
            //UsoLPIEEE754();
            //UsoLPOperadoresSobreFlujo();

            //UsoBloqueIf();
            //UsoBloqueIfElse();
            //UsoBloqueSwitch();
            //UsoCicloWhile();
            //UsoCicloDoWhile();
            //UsoCicloFor();
            //UsoCicloForEach();
            //UsoInterrupcionMEtodo();
            //UsoInterrupcionCiclo();
            //UsoInterrupcionInteracion();
            //UsoActividadProcuderal();

            //UsoParadigmaProcedural();
            //UsoPOOConceptos();
            //UsoPOOClasesYObjetos();
            //UsoPOOPropiedades();
            //UsoPOOParadigmaOrientadoOjetos();
            //UsoPOOMEtodos();

            //UsoPooEnsamblados();

            //UsoPOOConstructores();

            //UsoElementosInstanciaEstatico();
            //UsoPOORelacionesAsociacion();

            //UsoPOORelacionesEspecializacion();

            //UsoPOOHerenciaLaClaseRaiz();

            //UsoPOOHerenciaPErsonalizada();

            //UsoPOOHerenciaSobreEscritura();

            //UsoPOOHerenciaConstructores();

            //UsosPOOClasesAbstactas();

            //UsoActividadRelaciones();

            UsoPOORealizaciones();

        }

        #region "C# - Lenguaje Procedural"

        static void IntroNET()
        {
            Console.WriteLine("Curso de c# - Coppel Culiacan");
            Console.ReadLine();
            Console.ReadKey();
        }

        /// <summary>
        /// Ejemplo del uso de comentarios en c#.
        /// </summary>
        static void UsoLPComentarios()
        {
            // Autor: Diego Zazueta

            /*
                Curso: C#
                Objetivo: Mostrar los diferentes tipos de comentarios de C#.
             */

            // TODO: En espera de lo que resuelvan los usuarios en la proxima reunion. 
        }

        #region "Tipos datos y variables"

        static void UsoLPVariables()
        {
            /* Def.:
             * 
             * Declaración: <Tipo_dato> + <Nombre_variable> [ = Valor_inicial]
             * 
             * 
             * Tipos basicos:
             *      string      Nombre
             *      integer     Edad
             *      char        Sexo
             *      double      Importe
             *      boolean     Pagado
             *      
             *  Notas:
             *      C# no inicializa valores por defecto.
             *      C# permite declaraciones e inicializaciones multiples
             *      
             * 
             */

            string nombre = "No asignado";
            int entero1 = 10, entero2 = 20;

            Console.WriteLine(nombre);
            Console.WriteLine(entero1);
            Console.WriteLine(entero2);
            Console.ReadKey();
        }

        static void UsoLPSinonimos()
        {
            /*
             Def.: Representacion especifica (c#) de un tipo de dato base en el MSIL.
             * 
             * Int32 -> int
             * Int64 -> long
             * Boolean -> bool
             * string -> string
             * 
             * Nota:
             *     -Para realizar un codigo fuente comtatible en su mayor medida con los demas codigos de .NET 
             *      se aconseja usar la definicion de datos en modo MSLI.
             *      
             *     -El metodo GetType(), disponible en todos los tipos de :NET, permite conocer el tipo de una variable.
             */
            Int32 valor1 = 0;  //   MSIL
            int valor2 = 0;    //   C#

            Console.WriteLine(valor1.GetType().Name);
            Console.WriteLine(valor2.GetType().Name);
            Console.ReadKey();
        }

        static void UsoLPInferenciaTipos()
        {
            /*
             * Def.: La capacidad de reconocer el tipo de variable
             *       Soportada a partir de la version 3 del lenguaje.
             */

            int capacidad1 = 0;
            Int32 capacidad2 = 0;
            var capacidad3 = "diez";

            //Sentencia no valida

            //var capacidad3 = 10;

            Console.WriteLine(capacidad1.GetType().Name);
            Console.WriteLine(capacidad2.GetType().Name);
            Console.WriteLine(capacidad3.GetType().Name);
            Console.ReadKey();
        }

        static void UsoLPAusenciaValor()
        {
            /*
             * Tipos nulables: Son tipos basados en los tipos base que representan ausencia de valor. 
             * 
             * Nota:
             *  -Hacen uso de los tipos genericos.
             *  -c# soporta la sintaxis abreviada: <tipo_base> + ?
             *  -Los tipos nulables son soportados a partir de la version 3 del lenguaje.
             * 
             */

            //int añosExperiencia = 3;
            Nullable<int> añosExperiencia2 = null;
            int? añosExperiencia3 = null;

            if (añosExperiencia2.HasValue)
            {
                Console.WriteLine("Datos del candidato: ");
                Console.WriteLine("Años de experiencia: {0} años",añosExperiencia2);
                Console.ReadKey(); 
            }
            else
            {
                Console.WriteLine("Se desconoce los años de experiencia de la persona");
                Console.ReadKey();
            }
        }

        static int valor3 = 3;

        static void UsoLPAlcances()
        {
            /*
             * Def.:
             * 
             * Niveles:
             *  -Local
             *  -Bloque
             *  -Global
             */

            int valor1 = 0;
           
            if (true)
            {
                int valor2 = 0;   
            }
            else
            {

            }
        }

        enum NivelesSocio : byte
        {
            NoAsignado,
            Plata = 15,
            Silver = 15,
            Oro,
            Platino
        }
        static void UsoLPEnumeraciones()
        {
            // RN: Se desea almacenar el nivel de un cliente en base a las comprar que esre a realizado.
            //Los unicos niveles permisibles son: Platino, Oro y Plata.

            /*
             * String
             *  -Demaciados recursos para el conjunto de valores de negocio.
             *  -Validacion de integridad requerida. 
             * 
             * Char
             *  -Se requiere logica para resolver nivel.
             *  -Validacion de integridad requerida.
             *  -Falta de legibilidad.
             *  
             * Def.: Es un nuevo tipo de datos que se define apartir de un entero o conjunto de enteros.
             * 
             * Ventajas:
             *  -Legibilidad
             *  -Integridad de datos
             *  -Optimización
             * 
             * Notas:
             *  -Por defecto las enumeraciones de basan en Int32.
             *  -Se puede acotar el tipo entero base de la enumeracion.
             *  -Los valores de la enumeracion son posicionales. Iniciando en cero.
             *  -Se pueden asignar valores explicitos en las enumeraciones
             *  -El valor de una enumeracion depende del inmediato anterior.
             *  -El valor se puede asignar en diferentes ocaciones.
             * 
             */

            NivelesSocio nivel = NivelesSocio.Platino;

            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine(nivel);
            Console.WriteLine((int)nivel);
            Console.WriteLine(nivel.GetType().Name);
            Console.ReadKey();
        }

        #endregion

        #region "Operadores"

        static void UsoLPOperadores()
        {
            /*
             * Operadores y Metodos
             *
             *  -Los metodos pertenecen a las APIs por lo tanto son accesibles desde cualquier lenguaje.
             * 
             *  -Los datos se conocen como parametros.
             * 
             *  -Los operadores son especificos del lenguaje.
             *  -En los operadores los datos se conocen como operandos.
             *  -Cardinalidad: Numero de operandos requeridos por el operador.
             *      Unarios
             *      Binarios
             *      Ternarios
             *
             */

            string cad1 = "Promocion del mes: ";
            string cad2 = "20% de descuento en electronica.";

            Console.WriteLine(String.Concat(cad1,cad2));
            Console.WriteLine(cad1 + cad2);
            Console.ReadKey();
        }

        static void UsoLPOperadoresCategorias()
        {
            /*
             * Aritmeticos: +,-,*,/,%,++,--
             *  Notas:
             *      -Los operadores ++ y -- soportan notacion de prefijo y postfijo.
             *      -Si es un prefijo primero hace la operacion, luego la asignacion. (Antes)
             *      -Si es un postfijo primero hace la asignacion y luego la operacion. (Despues)
             *      -El operador / se apega al estandar IEEE754 de ECMA.
             *      
             * Compraracion: ==, !=, >, >=, <, <=
             * 
             * Logicos: !, &, &&, |, ||, ^
             *  Notas:
             *      Tabla de verdad (Y logico)
             *      
             *      EXP1    EXP2    Resultado
             *      v       v          v
             *      v       f          f
             *      f       v          f
             *      f       f          f
             *      
             *      Tabla de verdad (O Logico)
             *      
             *      EXP1    EXP2    Resultado
             *      v       v       v
             *      v       f       v
             *      f       v       v
             *      f       f       f
             *      
             *      Tabla de verdad (O logico exclusivo)
             *      EXP1    EXP2    Resultado
             *      v       v       F
             *      v       f       v
             *      f       v       v
             *      f       f       f
             * 
             * Concatenacion: +
             *  Notas:
             *      -Si uno de los operandos es numerico; las cadenas tienen precedencia.
             *      
             *
             * Asignacion: =
             * 
             * Asignacion Compuesta: +=, -=, *=, /=, %=
             * 
             * Manejo de objetos: new, =>, ~
             * 
             * Sobre flujo:
             * 
             * Condicionales: ?, :
             */

            int calificacion = 8;

            Console.ForegroundColor = 
                (calificacion > 7) ? ConsoleColor.Green : ConsoleColor.Red;

            Console.WriteLine(
                (calificacion>7)?"Aprobado!" : "Solicita una feha nueva"
                );

            Console.ReadKey();
        }

        static void ObtenerPromedio(double cantidad)
        {
            double promedio = -0 / cantidad;
            Console.WriteLine("El promedio es: {0}", promedio);
        }

        static void UsoLPIEEE754()
        {
            /*
             * ECMA: Es un estandar al que aplica varios lenguajes de programacion (.NET, Java, PHP, Javascript entre otros).
             * 
             * IEEE754: Es una norma de ECMA que indica que en operaciones de punto flotante entre cero no se generan excepciones.
             *          Solo valores especiales.
             *          
             *          Infinito
             *          Neum
             *          -Infinito
             */

            ObtenerPromedio(0);
            Console.ReadKey();
        }

        static void UsoLPOperadoresSobreFlujo()
        {
            /*
             * Notas:
             *  Por defecto c# no hace revisiones de sobreflujo; ni genera excepciones.
             *  
             *  Es responsabilidad del programador aplicar revisiones de sobre flujo.
             *  
             *  El checked se puede aplicar por expresion o por bloque.
             */

            int valor = 0;

            Console.WriteLine("Adicional: ");
            int adicional = int.Parse(Console.ReadLine());

            valor = checked(int.MaxValue + adicional);

            checked
            {
                valor = int.MaxValue + adicional;
                valor = int.MaxValue + adicional;
                valor = int.MaxValue + adicional;
                valor = int.MaxValue + adicional;
            }
            

            Console.WriteLine("Valor: {0}",valor);
           
        }

        #endregion

        #region "Estructuras de control"

        static void UsoBloqueIf()
        {
            /*
             * Notas:
             *  -Condiciona un conjunto de instrucciones a una expresion verdadera.
             *  -La expresion siempre se delimita entre parentesis.
             *  -Por defecto solo la siguiente expresion es parte del bloque.
             *  
             */

            int puntos = 500;

            if (puntos > 500)
            {
                Console.WriteLine("Aprobado!");
                Console.WriteLine("Felicidades...");
                Console.ReadKey();
            }  
        }

        static void UsoBloqueIfElse()
        {
            /*
             * Notas:
             *  -Se usa para tomar acciones si no se satisface la exprecion o condicional.
             *  -Por defecto solo la siguiente expresion es parte de bloque else.
             *  
             */

            int puntos = 500;

            if (puntos > 500)
            {
                Console.WriteLine("Aprobado!");
                Console.WriteLine("Felicidades...");
                Console.ReadKey();
            }
            else
            {
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine("Solicita una nueva fecha...");
                Console.ReadKey();
            }
        }

        static void UsoBloqueSwitch()
        {
            /*
             * Se usa para tomar acciones diferentes a valores diferentes generados por una misma expresiones.
             * 
             * se condidera una buena practica su uso en lugar de los ifs anidados por cuestiones de legibilidad.
             * 
             * La expresion evaluada por el bloque switch puede ser
             */

            Console.WriteLine("Clave de la ciudad: ");
            string ciudad = Console.ReadLine();
            string mensaje = "Temperatura: ";

            switch (ciudad)
            {
                case "CL":
                    mensaje += "Min 30 - Max 45";
                    break;
                case "AC":
                    mensaje += "Min 25 - Max 35";
                    break;
                case "MX":
                    mensaje += "Min 18 - Maz 27";
                    break;
                default:
                    mensaje = "Ciudad no registrada";
                    break;

            }
            Console.ReadKey();
        }

        static void UsoCicloWhile()
        {
            /*
             *  Notas:
             *      - Categoria: Coclos indefinidos (Condición).
             *      - Preevaluacion: 
             *          Existe la posibilidad que el cuerpo del ciclo jamas se ejecute.
             */

            string pass = "";

            while (pass != "123")
            {
                Console.WriteLine("Pasword: ");
                pass = Console.ReadLine(); 
            }

            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("Bienvenido al sistema...");
        }

        static void UsoCicloDoWhile()
        {
            /*
             *  Notas:
             *      - Categoria: Coclos indefinidos (Condición).
             *      - Preevaluacion: 
             *          Garantizan que almenos una vez se ejecute el cuerpo del ciclo.
             */

            string pass = "";

            do
            {
                Console.WriteLine("Pasword: ");
                pass = Console.ReadLine();
            } while (pass != "123");

            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("Bienvenido al sistema...");
        }

        static void UsoCicloFor()
        {
            string secuencia = "";

            for (int indice = 1; indice < 25; indice++)
            {
                secuencia += indice + " ";
            }

            //Modificacion del incremento.
            secuencia = "";

            for (int indice = 25; indice >= 1; indice--)
            {
                secuencia += indice + " ";
            }
            Console.WriteLine(secuencia);
            Console.ReadKey();
        }

        static void UsoCicloForEach()
        {
            /*
              Notas:
             *  -Se considera una estructura mas eficiente que su equivalente tradicional.
             *  -No requiere la declaracion de una variable de bloque para recorrer cada elemento.
             *  -No requiere una condicion en cada iteracion.
             *  -Aplica exclusivamente a contenedor.
             */
            string cadena = "Coppel";

            foreach (char item in cadena)
	        {
		        Console.WriteLine(item.ToString().ToUpper());
                Console.ReadKey();
	        }
        }

        static void UsoInterrupcionMEtodo()
            /*
             * -return provoca la iterrupcion de todo el metodo.
             * -si el metodo declara que debe regresar un valor; la clausula return se debe completar con un valor correspondiente.
             */
        {
            string secuencia = "";

            for (int indice = 0; indice <= 25 ; indice++)
            {
                if (indice == 15)
                {
                    return;
                }
                secuencia += indice + " ";
            }
            Console.WriteLine(secuencia);
        }

        static void UsoInterrupcionCiclo()
       
        {
            string secuencia = "";

            for (int indice = 0; indice <= 25; indice++)
            {
                if (indice == 15)
                {
                    break;
                }
                secuencia += indice + " ";
            }
            Console.WriteLine(secuencia);
        }

        static void UsoInterrupcionInteracion()

        {
            string secuencia = "";

            for (int indice = 0; indice <= 25; indice++)
            {
                if (indice == 15)
                {
                    continue;
                }
                secuencia += indice + " ";
            }
            Console.WriteLine(secuencia);
            Console.ReadKey();
        }

        #endregion

        static void UsoActividadProcuderal()
        {
            /*
             * RN: Encontrar una secuencia de pares.
             * 
             * Consideraciones:
             *  -El programa va a necesitar 3 enteros al usuario.
             *      (Inicio,fin y cantidad).
             *      
             *  -Inicio: Representa el inicio de la secuencia.
             *  -Fin: representa el fin de la secuencia
             *  -Cantidad: el numero de pares a mostrar en la secuencia.
             *  -Los valores de inicio y fin determinaran el sentido de la secuencia.
             *  -Manejar valores positivos(no se requiere que el programa valide) 
             * 
             * Pruebas de escritorio
             *  Inicio      Fin     Cantidad        Resultado
             *  25          10          5               24,22,20,18,16
             *  3           9           8               4,6,8
             *  63          63          10              No hay pares
             *  
             */

            Console.WriteLine("Introduce valor de inicio");
            int inicio = int.Parse(Console.ReadLine());
            
            Console.WriteLine("Introduce valor de fin");
            int fin = int.Parse(Console.ReadLine());

            if (inicio == fin)
            {
                Console.WriteLine("No hay pares a mostrar");
            }
            else
            {
                Console.WriteLine("Introduce la cantidad de pares a mostrar");
                int cantidad = int.Parse(Console.ReadLine());
                
                string secuencia = "";

                for (int i = 2; i < fin; i+=2)
                {
                   
                }
            }

            Console.ReadKey();
         
        }

        #endregion

        #region "C# - lenguaje Orientado a objetos"

        #region "Conceptos"

        static void UsoParadigmaProcedural()
        {
            //Encontrar eñ mayor de 3 numeros.

            /*
             *  Inconvenientes de la programacion procedural
             *      -El codigo funcional esta fuertemente acoplado a la aplicacion.
             *      -Se dificulta el mantenimiento al hacer ajustes directamente en la aplicacion.
             *      -No hay reutilizacion de código en distintos ensamblados.
             */

            int ent1 = 0, ent2 = 0, ent3 = 0, resultado = 0;

            if (ent1 > ent2)
            {
                if (ent1 > ent3)
                {
                    resultado = ent1;
                }
            }

            if (ent2 > ent1)
            {
                if (ent2 > ent3)
                {
                    resultado = ent2;
                }
            }

            if (ent3 > ent1)
            {
                if (ent3 > ent2)
                {
                    resultado = ent3;
                }
            }

            Console.WriteLine("El mayor valor es: {0}",resultado);
        }

        static void UsoPOOConceptos()
        {
            /*
             * Programa (general)           POO
             *  -Datos                  -Propiedades (Datos)
             *  -Procesos               -Métodos    (Procesos)
             *  -Salidas                
             *  
             * Filosofía de POO
             *  -Entidad Real           -Entidad Lógica
             *      *carta                  *email
             *      *bancos                 *banca electronica
             *      *libros                 *Libros digitales
             *      
             * Fases de POO
             *  -Análisis               Qué(s)                Analistas de negocio
             *  -Diseño                 Qué(s)/Cómo(s)        Arquitectos de software
             *  -Programación           Cómo(s)               Desarrolladores/Programadores
             *  
             * Elementos orientados a objetos
             *                       Abstracción
             *      Entidad Real                    Entidad Logica
             *         Libro
             *          Editorial                   Editorial
             *          Titulo                      Titulo
             *          N° de paginas               N° paginas
             *          Peso
             *          Tipo de papel
             *          Acabado
             *          ----------------            ---------------
             *          Leer                        Almacenar
             *          Hojear                      Dar de baja
             *          Vender                      Actualizar
             *          Deshojarlo                  
             *  
             * Clasificación de elementos (Clase)
             * Espacios de nombres (NameSpace)
             * Ensamblados
             * 
             * Jerarquia de Elementos .NET
             *  Framework
             *      Ensamblado
             *          Espacio de nombres
             *              Clases
             *                  -Propiedades
             *                  -Métodos
             *  
             * 
             * 
             */
        }

        class Pelicula
        {
        }

        static void UsoPOOClasesYObjetos()
        {
            /*
             * Clase: Es la especificacion de la clase.
             * Objeto: Representacion de la memoria de la clase.
             */
            Pelicula pel1 = new Pelicula(); // Objeto.
            Pelicula pel2 = new Pelicula(); // Objeto.
            Pelicula pel3 = null; // Declaracion.

            Console.WriteLine(pel1);
        }

        #endregion

        #region "Propiedades"
        
        class Alumno
        {
            //Variables publicas.
            public string Nombre;

            //Procedimientos de propiedades.
            private string _Apellido;
            public string Apellido 
            {
                get
                {
                    return _Apellido.ToUpper();
                }
                set
                {
                    _Apellido = value;
                }
            }

            //Procedimiento de propiedad solo lectura
            public string Matricula 
            { 
                get
                {
                    return "ALU00001";
                }
            }

            //Propiedades autoimplementadas
            public string Direccion { get; set; }

        }
        static void UsoPOOPropiedades()
        {
            /*
             * Propiedades:
             *  Variables publicas
             *  Procedimientos de propiedad - Lectura / Escritura
             *  Procedimientos de propiedad - Solo lectura
             *  propiedades autoimplementadas
             */

            Alumno objAlumno = new Alumno();
            Alumno objAlumno2 = new Alumno();

            //Asignacion o escritura
            objAlumno.Nombre = "Ana";
            objAlumno.Apellido = "Zazueta";
            objAlumno.Direccion = "Av. libertad centro 1321";

            objAlumno2.Nombre = "Luis";

            //Consulta o lectura
            Console.WriteLine("Datos del alumno");
            Console.WriteLine("Nombre: {0} {1}",objAlumno.Nombre,objAlumno.Apellido);
            Console.WriteLine("Matricula: {0}",objAlumno.Matricula);
            Console.WriteLine("Direccion: {0}",objAlumno.Direccion);

            Console.ReadKey();
           
        }

        static void UsoPOOParadigmaOrientadoOjetos()
        {
            MisMatematicas objMisMatematicas = new MisMatematicas();
            objMisMatematicas.entero1 = 80;
            objMisMatematicas.entero2 = 45;

            Console.WriteLine("El mayor: {0}",objMisMatematicas.mayor);
            Console.ReadKey();
        }

        class MisMatematicas
        {
            public int entero1 { get; set; }
            public int entero2 { get; set; }

            public int mayor 
            {
                get
                {
                    int resultado = 0;

                    if (entero1 > entero2)
                    {
                        resultado = entero1;
                    }
                    else
                    {
                        resultado = entero2;
                    }
                    return resultado;
                }
            }
        }

        #endregion

        #region "Metodos"

        static void UsoPOOMEtodos()
        {
            /*
             * MEtodos:
             *  -Acciones que puede realizar el objeto, generalmentre sobre las propiedades
             *  
             * Variantes:
             *      -Valor de regreso
             *          *En la declaracion del metodo se indica el tipo de dato del valor a regresar.
             *          *En caso de que el metodo no regrese ningun valor se debe calificar con la palabra reservada void.
             *          *El hecho que metodo genere un valor de regreso no obliga al objeto a usar dicho valor.
             *          
             *      -Parametros
             *          *Son datos que requiere de manera particular el metodo.
             *          *Funcionan como variables locales al metodo.
             *          *No se soporta la inferencia de tipos (Var).
             *          
             *      -Argumentos Nombrados
             *          * Ventajas: Legibilidad y Flexibilidad
             *         
             *      -Parametros opcionales
             *          *Permiten definir un valor por defecto al parametro.
             *          *Se pueden usar combinados con parametros requeridos; siempre y cuando los opcionales sean los ultimos en la lista de parametros.
             *          
             *      -Polimorfismo de estado
             *          *Estado (Propiedades)
             *              Condicion de un objeto en un momento determinado.
             *              Cuando las propiedades modifican el estado de un objeto.
             *          *El comportamiento de un metodo se ve alterado por los valores de las propiedades del objeto.
             *          
             *      -Paso de parametros
             *          *Por valor
             *              Tipo de paso por defecto.
             *              El parametro tiene un espacio de memoria propio.
             *         *Por referencia
             *              Se debe calificar tanto el parametro como el argumento con el operador ref.
             *              El parametro comparte el espacio de memoria del argumento.
             *         *De salida
             *              Se debe calificar tanto el parametro como el argumento con el operador out.
             *              El valor se genera despues de la llamada al metodo.
             * 
             *      -Tipo de firma
             *          Se constituye por:
             *              Nombre metodo
             *              Numero parametros
             *              Tipo de datos de parametros
             *              Orden de parametros 
             *              Tipo de paso de parametros (valor,referencia o salida)
             *              
             *      -Poliformismo de Métodos (Sobre carga)
             *          
             *          Operacion                   Metodo
             *           ¿Qué?                      ¿Cómo?
             *           
             *          Sobre carga: Poliformismo en base una operacion implementada en metodos con firmas diferentes.
             *          
             *          C# aplica conversiones implicitas para asociar las formas; si hay una firma explicita, esta toma precedencia.
             *          
             *      -Parametros de Longitud Variable
             *         *Permiten que el metodo reciba un numero variable de argumentos del tipo dado.
             *         *En la declaracion del parametro se debe usar el operador (params) y la notacion de arreglos. P.ej. (Params string[] temas)
             *         *Internamente, en el metodo la variable es un arreglo.
             *         *se puede combinar con sobre carga; esta ultima toma precedencia.
             *         
             *
             *          
             */

            Curso objCurso = new Curso();
            objCurso.Nombre = "Fundamentos de XML";
            objCurso.Duracion = 20;

            //objCurso.Mostrar();
            //DateTime vigencia = objCurso.Publicar();
            //Console.WriteLine("Vigencia de la publicacion: " + vigencia);
            //objCurso.Cancelar("Falta de pago");
            //objCurso.Asignar("Culiacan", 25);
            //objCurso.Asignar(Sede: "Culiacan", NoAlumnos: 25);

            //objCurso.AplicarDescuento();
            //objCurso.AplicarDescuento("Por la cantidad de alumnos");
            //objCurso.Duracion = 120;
            //objCurso.AsignarDescansos();

            //int v1 = 50, v2 = 25, s1;

            //objCurso.TipoPasoParametros(v1, ref v2,out s1);
            //Console.WriteLine("Paso por valor: {0}",v1);
            //Console.WriteLine("Paso por referencia: {0}",v2);
            //Console.WriteLine("Parametro de salida: {0}",s1);
            //Console.ReadLine();

            //objCurso.Pagar(123);
            objCurso.AgregarNuevoTema("Cap1");
            objCurso.AgregarNuevoTema("CSS Hojas de estilo en XML","HTML5");
            Console.ReadKey();

        }

        class Curso
        {
            public string Nombre { get; set; }
            public int Duracion { get; set; }
            public string Motivo { get; set; }

            public void Mostrar()
            {
                Console.WriteLine("Datos del curso: ");
                Console.WriteLine("Nombre: {0}",Nombre);
                Console.WriteLine("Duracion: {0} horas.",Duracion);
            }

            public DateTime Publicar()
            {
                Console.WriteLine("El curso {0} ha sido publicado",Nombre);
                return DateTime.Now.AddMonths(3);
            }

            public void Cancelar(string Motivo)
            {
                Console.WriteLine("El curso {0} ha sido cancelado",Nombre);
                Console.WriteLine("Motivo: {0}",Motivo);
            }

            public void Asignar (string Sede, int NoAlumnos)
            {
                Console.WriteLine("El curso {0} ha sido asignado", Nombre);
                Console.WriteLine("Sede: {0}",Sede);
                Console.WriteLine("Numero de alumnos: {0}",NoAlumnos);
                Console.ReadKey();
            }

            public void AplicarDescuento(string TipoDescuento = "Por ser exalumno")
            {
                Console.WriteLine("El curso {0} tiene un descuento",Nombre);
                Console.ReadLine();
            }

            public void AsignarDescansos()
            {
                if (Duracion < 30)
                {
                    Console.WriteLine("Tomar un descanso al dia...");
                }
                if (Duracion > 60)
                {
                    Console.WriteLine("Tomar varios descansos...");
                }
                Console.ReadLine();
            }

            public void TipoPasoParametros(int valor1,ref int valor2, out int salida1)
            {
                valor1 = 300;
                valor2 = 500;
                salida1 = 750;
            }

            public void Pagar(string NoTDC)
            {
                Console.WriteLine("El curso {0} ha sido pagado.",Nombre);
                Console.WriteLine("Forma de pago: Tarjeta de crédito.");
                Console.WriteLine("Promocion: Pago a meses sin intereses");
            }

            public void Pagar(double Importe)
            {
                Console.WriteLine("El curso {0} ha sido pagado.", Nombre);
                Console.WriteLine("Forma de pago: En efectivo.");
                Console.WriteLine("Promocion: 10% desc en la siguiente compra.");
            }

            public void AgregarNuevoTema(string NvoTema)
            {
                Console.WriteLine("Recursos ocupados por la BD..");
                Console.WriteLine("El contenido del curso ha mejorado: ");
                Console.WriteLine("Nuevo temas: {0}",NvoTema);
                Console.WriteLine();
            }

            public void AgregarNuevoTema(params string[] temas)
            {
                Console.WriteLine("Recursos en la BD");
                Console.WriteLine("Se agregaron los siguientes temas");
                foreach (string tema in temas)
                {
                    Console.WriteLine("\tTema: {0}",tema);
                }
                Console.WriteLine();
            }
        }

        #endregion

        #region "Ensamblados"
        //RN: Hacer un programa orientado a objetos que permita convertir de grados C° a grados F° y viceversa.

        static void UsoPooEnsamblados()
        {
            // A cuanto equivale 46° en F?

           Coppel.funciones.ConvertidorTemperatura obj = new ConvertidorTemperatura();

            Console.Write("Grados C°: ");
            obj.GradosC = double.Parse(Console.ReadLine());
            obj.Conversion = ConvertidorTemperatura.TipoConversion.DeCaF;

            Console.WriteLine("{0}°C equivalen a {1}° F",obj.GradosC,obj.Convertir());
            Console.ReadLine();


        }
        #endregion

        #region "Constructores"
        class Empresa
        {
            public string RazonSocial { get; set; }
            public int NoEmpleados { get; set; }
            public string Direccion { get; set; }

            public Empresa()
            {
                RazonSocial = "No Asignada";
            }

            public Empresa(string RazonSocial, int NoEmpleados,string Direccion)
            {
                this.RazonSocial = RazonSocial;
                this.NoEmpleados = NoEmpleados;
                this.Direccion = Direccion;
            }
        }
        
        static void RegistroEmpresa(Empresa objEmpresa)
        {
            Console.WriteLine("Datos de la empresa");
            Console.WriteLine("Razon social: {0}",objEmpresa.RazonSocial);
            Console.WriteLine("NoEmpleados: {0}",objEmpresa.NoEmpleados);
            Console.WriteLine("Direccion: {0}",objEmpresa.Direccion);
            Console.ReadLine();
        }


        static void UsoPOOConstructores()
        {
            /*
             * Constructor
             *  Def.:
             *      Inicializa los valores de las propiedades:
             *          En base al tipo de dato.
             *              Numericos -> 0
             *              Cadenas -> Cadenas vacias
             *              Boleano -> False
             *              Caracter -> Espacio
             *              Objeto -> null
             * 
             *      Tipos:
             *          -Constructor por defecto.
             *              No re sequiere codigo especial.
             *              Se incluye por parte de la plataforma .NET
             *              
             *          -Constructor sin parametros
             *              Sirve para personalizar el proceso de inicializacion.
             *              
             *          -Constructores personalizados
             *              Se usan para asignar valores a las propiedades desde que se crea el objeto.
             *              
             *          -Inicializadores de Objetos
             *              Sintaxis de C# que permite asociar valores a las propiedades sin depender del diseño de constructores de la clase.
             *              No soportada en las primeras versiones del lenguaje.
             *              
             *          -Validacion de estado
             *              Recnica de diseño basada en constructores que asegura que un objeto secree con valores de negocio
             *              Consiste en incluir constructores personalizados con parametros para asi evitar el constructor por defecto (de fabrica).
             */

            //Empresa objEmpresa = new Empresa();

            Empresa objEmpresa = new Empresa();
            objEmpresa.RazonSocial = "Mi EMpresa SA de CV";
            objEmpresa.NoEmpleados = 12345;
            objEmpresa.Direccion = "En algun lugar";
            RegistroEmpresa(objEmpresa);

            Empresa objEmpresa1 = new Empresa("Mi Empresa SA de CV", 12345, "En algun lugar");
            RegistroEmpresa(objEmpresa1);

            RegistroEmpresa(new Empresa("Mi EMpresa SA de CV", 12345, "En algun lugar"));

            //Inicializador de objetos
            RegistroEmpresa(new Empresa() {RazonSocial = "Mi EMpresa SA de CV",
                                            NoEmpleados = 12345,
                                            Direccion = "En algun lugar"});
            Console.ReadLine();


        }
        #endregion

        #region "Elementos de Instancia y Estaticos"
        
        static void UsoElementosInstanciaEstatico()
        {
            /*
             * Los elementos pueden ser de instancia (particulares) o estaticos (generales).
             * Si son de instancia se invocan a partir de un objeto.
             * Si son estaticos se invocan a partir de la clase.
             * 
             * Un elemento de instancia puede referirse a elementos de instanca y estaticos.
             * 
             * Un elemento estatico solo puede referirse a elementos estaticos.
             * 
             * El operador this hace referencia a elementos de la instancia.
             * 
             * Los valores constantes por definicion son elementos estaticos.
             * 
             * A los elementos estaticos tambien se les suelen llamar de clase o compartidos.
             * 
             * Constructores estaticos:
             *  Soportados por las ultimas versiones del lenguaje.
             *  Permiten inicializar propiedades estaticas.
             *  No llevan calificador de alcance; por definicion son publicos.
             *  No soportan parametros. (No soportan el concepto de sobrecarga)
             * 
             */
            Salon.Escuela = "San Sebastian";

            Salon objSalon = new Salon();
            objSalon.Capacidad = 30;
            objSalon.Registrar();


            Salon.BorrarTodo();

            Console.WriteLine(Salon.CAPACIDAD_LIMITE);
            Console.WriteLine("OK - UsoElementosInstanciaEstatico");
            Console.ReadKey();
        }

        class Salon
        {
            public const int CAPACIDAD_LIMITE = 40;


            public int Capacidad { get; set; }
            public static string Escuela { get; set; }

            public void Registrar()
            {
                
            }

            public static void BorrarTodo()
            {
                   
            }

            static Salon()
            {

            }

        }
        #endregion

        #region "Relaciones"
        /*
         *          Sentencia                   Ejemplo                         Nombre              Implementacion
         *          Tiene un           Poliza TIENE UN Asegurado              Asociacion             Tipo de dato 
         *          Es un                Taxi ES UN Automovil               Especializacion            Herencia
         *          Actua como un     Un cuadro ACTUA COMO UN decorador      Realizaciones            Interfaces
         */
        
       #endregion

        #region "Relaciones - Asociacion"
        
        class Asegurado
        {
            public string Nombre { get; set; }
            public bool EsFumador { get; set; }
        }

        class Poliza
        {
            // Antipatron de Diseño "El todo poderoso" que le carguen a una clase mas responsabilidades de las que debe.
            public int Folio { get; set; }
            public double SumaAgregada { get; set; }
            public Asegurado Asegurado { get; set; } //Asociacion
        }

        static void UsoPOORelacionesAsociacion()
        {
            Poliza objPoliza = new Poliza();

            objPoliza.Asegurado = new Asegurado() { Nombre = "Luis Silva", EsFumador = true };
            objPoliza.Folio = 123;
            objPoliza.SumaAgregada = 50000000.00;

            Console.WriteLine("Asegurado {0}, es fumador? {1}",objPoliza.Asegurado.Nombre,objPoliza.Asegurado.EsFumador);
            Console.ReadKey();
        }

        #endregion

        #region "Relaciones - Herencia"

        static void UsoPOORelacionesEspecializacion()
        {
            /*
             * Sentencia: ES UN
             * Nombre Especializacion
             * Clase Base / Anteprecesora / Padre / Super Clase
             * Clase Derivada / Desendente / Hija / Sub Clase
             * Herencia Multiple
             *      Una clase derivada tiene mas de una clase.
             *      C# no soporta la herencia multiple
             * Herencia de niveles Multiples
             *      Una derivada se convierte en base de otra.
             *      Soportado en c#
             *      P.ej:
             *          Telefono
             *              Celular
             *                  Smartphone
             *                  
             * La clase Raiz
             *      System.Object
             *      Es la clase base de todas las clases de .NET
             *      Es una relacion hecha por definicion.
             *      
             * Polimorfismo de jerarquis de objetos - Sobre Escritura
             *      Sobre Escritura - Flexible
             *      Sobre Escitura - Rigida
             */
        }

        class Tienda
        {
            public string Nombre { get; set; }
        }

        static void UsoPOOHerenciaLaClaseRaiz()
        {
            /*
             * Equals:
             *      Permite la comparacion entre objetos (en base a las referencias de memoria).
             * 
             * HashCode:
             *      Representacion numerica del area de memoria.
             *      
             * ToString:
             *      Devuelve el nombre completo de la clase a la que pertenece el objeto.
             *      
             * GetType:
             *      Devuelve informacion especifica del tipo del objeto.
             */

            Tienda objTienda1 = new Tienda() { Nombre = "Plaza Fiesta" };
            Tienda objTienda2 = new Tienda() { Nombre = "Elektra" };

            objTienda1 = objTienda2; //Referencias

            Console.WriteLine(objTienda1.Equals(objTienda2));
            Console.WriteLine(objTienda1.GetHashCode());
            Console.WriteLine(objTienda2.GetHashCode());
            Console.WriteLine(objTienda1.ToString());
            Console.WriteLine(objTienda1.GetType().Assembly.FullName);
            Console.ReadKey();
        }


        class Libro
        {
            public string Titulo { get; set; }
            public int NoPaginas { get; set; }

            public void Leer()
            {

            }

            public virtual void Abrir()
            {
                Console.WriteLine("Levantar la portada - Movimiento manual");
                Console.ReadKey();
            }

            public void Cerrar()
            {
                Console.WriteLine("El libro se ha cerrado");
            }
        }

        class EBook : Libro
        {
            public string SelloDigital { get; set; }

            public override void Abrir()
            {
                Console.WriteLine("Click sobre la aplicacion");
                Console.ReadKey();
            } 

            new public void Cerrar()
            {
                Console.WriteLine("El libro se ha cerrado correctamente");
            }

            public EBook()
            {
                Console.WriteLine("Constructor de EBook - (Derivada)");
            }
        }

        static void UsoPOOHerenciaPErsonalizada()
        {
            EBook objEBook = new EBook();

            //Clase base
            objEBook.Titulo = "El titulo";
            objEBook.NoPaginas = 100;
            //Clase derivada
            objEBook.SelloDigital = "adjlahjkdsfhdskfl";
            objEBook.Leer();
        }

        static void AdministracionBiblioteca(Libro obj)
        {
            //obj.Abrir();
            obj.Cerrar();
            Console.ReadKey();
        }

        static void UsoPOOHerenciaSobreEscritura()
        {
            //EBook objEBook = new EBook();
            //objEBook.Abrir();
            AdministracionBiblioteca(new Libro());
            AdministracionBiblioteca(new EBook());
        }

        class Automovil
        {
            public Automovil(string NoPlacas)
            {

            }
        }

        class Taxi : Automovil
        {
            public Taxi():base("") //Llamar un contructor de la clase base desde una clase derivada
            {

            }
        }

        static void UsoPOOHerenciaConstructores()
        {
            new EBook();
            new Automovil("123-ABC");
            new Taxi();
            Console.ReadKey();
        }

        static void UsosPOOClasesAbstactas()
        {
            //EditorTexto obj = new EditorTexto();
            RedactarDocumento(new Notepad());
            RedactarDocumento(new Winword());
            RedactarDocumento(new NotepadPlus());
        }

        static void RedactarDocumento(EditorTexto obj)
        {
            obj.Escribir();
            Console.ReadLine();
        }

        abstract class EditorTexto
        {
            //
            public abstract void Escribir();
            public abstract void Copiar();
            public abstract void Pegar();
        }

        class Notepad : EditorTexto
        {

            public override void Escribir()
            {
                Console.WriteLine("Escribe con formato basico - Notepad");
            }

            public override void Copiar()
            {
                
            }

            public override void Pegar()
            {
                
            }
        }

        sealed class Winword : EditorTexto
        {

            public override void Escribir()
            {
                Console.WriteLine("Escribe con formato basico - Winwird");
            }

            public override void Copiar()
            {
                
            }

            public override void Pegar()
            {
                
            }
        }

        class NotepadPlus : Notepad
        {
            public override void Escribir()
            {
                base.Escribir();
                Console.WriteLine("Con correccion de ortografia");
            }
        }

        #endregion

        #region "Actividad"
        
        static void UsoActividadRelaciones()
        {
            /*
             * RN: Hacer un programa orientado a objetos que muestre al comensal lo que debe pagar de su consumo, considerado que:
             *      Hasta la fecha el restaurante maneja diferentes tipos de platillos (Posteriormente se piensa expandir la oferta)
             *      
             *     Los platillos que se manejan actualmente son:
             *          Cortes
             *          Mariscos
             *          Ensalada
             *     
             *      Todos los platillos tienen un nombre y un precio
             *      
             *      El programa debe mostrar los platillos consumidos y el total a pagar.
             *      
             *      Los platillos tienen caracteristicas especiales:
             *          cortes: un termino de coccion.
             *          Mariscos: Fecha de veda.
             *          Ensaladas: Aderezo.
             */

            cortes objCortes = new cortes() {Nombre = "Filete",precio = 100 };
            Ensaladas objEnsalada = new Ensaladas() {Nombre = "Ensalada cesar", precio = 50 };

            Comanda objComanda = new Comanda();
            objComanda.calcularTotal(objCortes, objEnsalada);
            Console.ReadKey();
            

        }

        abstract class platillo
        {
            public string Nombre { get; set; }
            public double precio { get; set; }

        }

        class cortes : platillo
        {
            public double Termino { get; set; }

        }

        class Mariscos : platillo
        {
            public DateTime FechaVeda { get; set; }
        }

        class Ensaladas : platillo
        {
            public string Aderezo { get; set; }
        }

        class Comanda 
        {
            public void calcularTotal(params platillo[] platillos)
            {
                double resultado = 0.0;

                foreach (platillo item in platillos)
                {
                    Console.WriteLine("{0} {1}",item.Nombre,item.precio.ToString("c"))
                        ;
                    resultado += item.precio;
                }
                Console.WriteLine("==========================================");
                Console.WriteLine("Total: {0}",resultado.ToString("c"));
            }
        }
        #endregion

        static void UsoPOORealizaciones()
        {
            /*
             * Interfaz Nativa / Por defecto / Primaria
             * Alta cohesion
             */
            Recepcion(new Programador());
        }

        class Programador
        {
            public double Sueldo { get; set; }

            public void programar()
            {

            }

            public void AtenderCllientes()
            {
                Console.WriteLine("Atiende a los clientes sin mucho animo.");
                Console.ReadKey();
            }
        }

        class Secretaria
        {
            public void Contestar()
            {

            }

            public void AtenderCliente()
            {
                Console.WriteLine("Atiende cliente con coordialidad");
                Console.WriteLine();
            }
        }

        static void Recepcion(Programador obj)
        {
            obj.AtenderCllientes();
        }

        #endregion
    }
}
